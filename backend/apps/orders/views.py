content='from rest_framework import viewsets, status\nfrom rest_framework.decorators import action\nfrom rest_framework.response import Response\nfrom rest_framework.permissions import IsAuthenticated\nfrom django.db import transaction\nfrom django.shortcuts import get_object_or_404\nfrom django.conf import settings\nimport stripe\nimport logging\n\nfrom .models import Order, OrderItem\nfrom .serializers import OrderSerializer, OrderCreateSerializer, OrderItemSerializer\nfrom apps.products.models import Product\nfrom apps.notifications.utils import send_order_notification\n\nlogger = logging.getLogger(__name__)\nstripe.api_key = settings.STRIPE_SECRET_KEY\n\n\nclass OrderViewSet(viewsets.ModelViewSet):\n    """\n    ViewSet for managing orders with payment processing capabilities.\n    \n    Provides CRUD operations for orders along with payment processing,\n    order status updates, and order history retrieval.\n    """\n    serializer_class = OrderSerializer\n    permission_classes = [IsAuthenticated]\n    \n    def get_queryset(self):\n        """Return orders for the authenticated user."""\n        return Order.objects.filter(user=self.request.user).select_related(\'user\').prefetch_related(\'items__product\')\n    \n    def get_serializer_class(self):\n        """Return appropriate serializer based on action."""\n        if self.action == \'create\':\n            return OrderCreateSerializer\n        return OrderSerializer\n    \n    def create(self, request):\n        """\n        Create a new order with payment processing.\n        \n        Expects:\n        - items: List of {product_id, quantity} objects\n        - payment_method_id: Stripe payment method ID\n        - shipping_address: Address object\n        """\n        serializer = self.get_serializer(data=request.data)\n        serializer.is_valid(raise_exception=True)\n        \n        try:\n            with transaction.atomic():\n                # Create order\n                order = self._create_order(serializer.validated_data)\n                \n                # Process payment\n                payment_intent = self._process_payment(order, request.data.get(\'payment_method_id\'))\n                \n                # Update order with payment info\n                order.stripe_payment_intent_id = payment_intent.id\n                order.payment_status = \'processing\'\n                order.save()\n                \n                # Send confirmation notification\n                send_order_notification(order, \'order_created\')\n                \n                logger.info(f"Order {order.id} created successfully for user {request.user.id}")\n                \n                return Response(\n                    OrderSerializer(order).data,\n                    status=status.HTTP_201_CREATED\n                )\n                \n        except stripe.error.CardError as e:\n            logger.error(f"Payment failed for user {request.user.id}: {e}")\n            return Response(\n                {\'error\': \'Payment failed\', \'details\': str(e)},\n                status=status.HTTP_400_BAD_REQUEST\n            )\n        except Exception as e:\n            logger.error(f"Order creation failed for user {request.user.id}: {e}")\n            return Response(\n                {\'error\': \'Order creation failed\', \'details\': str(e)},\n                status=status.HTTP_400_BAD_REQUEST\n            )\n    \n    def _create_order(self, validated_data):\n        """Create order and order items."""\n        items_data = validated_data.pop(\'items\')\n        \n        # Calculate total amount\n        total_amount = 0\n        order_items = []\n        \n        for item_data in items_data:\n            product = get_object_or_404(Product, id=item_data[\'product_id\'])\n            \n            # Check stock availability\n            if product.stock < item_data[\'quantity\']:\n                raise ValueError(f"Insufficient stock for product {product.name}")\n            \n            item_total = product.price * item_data[\'quantity\']\n            total_amount += item_total\n            \n            order_items.append({\n                \'product\': product,\n                \'quantity\': item_data[\'quantity\'],\n                \'price\': product.price,\n                \'total\': item_total\n            })\n        \n        # Create order\n        order = Order.objects.create(\n            user=self.request.user,\n            total_amount=total_amount,' additional_kwargs={} response_metadata={'id': 'msg_01V8WFoz9TBrR4bFcVy6RVTD', 'model': 'claude-sonnet-4-20250514', 'stop_reason': 'max_tokens', 'stop_sequence': None, 'usage': {'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0, 'input_tokens': 403, 'output_tokens': 1024, 'service_tier': 'standard'}} id='run--e43719c6-0974-4d51-8548-c19ec8f968af-0' usage_metadata={'input_tokens': 403, 'output_tokens': 1024, 'total_tokens': 1427, 'input_token_details': {'cache_read': 0, 'cache_creation': 0}}