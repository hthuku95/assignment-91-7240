content='import json\nimport logging\nfrom channels.generic.websocket import AsyncWebsocketConsumer\nfrom channels.db import database_sync_to_async\nfrom django.contrib.auth.models import AnonymousUser\nfrom django.core.exceptions import ObjectDoesNotExist\nfrom .models import Notification\nfrom ..users.models import User\n\nlogger = logging.getLogger(__name__)\n\n\nclass NotificationConsumer(AsyncWebsocketConsumer):\n    """\n    WebSocket consumer for handling real-time notifications.\n    Manages user connections and broadcasts notifications to authenticated users.\n    """\n\n    async def connect(self):\n        """\n        Handle WebSocket connection.\n        Only authenticated users can connect to receive notifications.\n        """\n        self.user = self.scope["user"]\n        \n        if isinstance(self.user, AnonymousUser):\n            logger.warning("Anonymous user attempted to connect to notifications")\n            await self.close(code=4001)\n            return\n\n        self.user_group_name = f"notifications_{self.user.id}"\n        \n        try:\n            # Join user-specific notification group\n            await self.channel_layer.group_add(\n                self.user_group_name,\n                self.channel_name\n            )\n            \n            await self.accept()\n            logger.info(f"User {self.user.id} connected to notifications")\n            \n            # Send connection confirmation\n            await self.send(text_data=json.dumps({\n                \'type\': \'connection_established\',\n                \'message\': \'Connected to notifications\'\n            }))\n            \n            # Send unread notifications count\n            unread_count = await self.get_unread_notifications_count()\n            await self.send(text_data=json.dumps({\n                \'type\': \'unread_count\',\n                \'count\': unread_count\n            }))\n            \n        except Exception as e:\n            logger.error(f"Error connecting user {self.user.id}: {str(e)}")\n            await self.close(code=4000)\n\n    async def disconnect(self, close_code):\n        """\n        Handle WebSocket disconnection.\n        Remove user from notification group.\n        """\n        if hasattr(self, \'user_group_name\'):\n            await self.channel_layer.group_discard(\n                self.user_group_name,\n                self.channel_name\n            )\n            logger.info(f"User {self.user.id} disconnected from notifications")\n\n    async def receive(self, text_data):\n        """\n        Handle messages received from WebSocket.\n        Process notification-related actions like marking as read.\n        """\n        try:\n            text_data_json = json.loads(text_data)\n            action = text_data_json.get(\'action\')\n            \n            if action == \'mark_as_read\':\n                notification_id = text_data_json.get(\'notification_id\')\n                if notification_id:\n                    success = await self.mark_notification_as_read(notification_id)\n                    await self.send(text_data=json.dumps({\n                        \'type\': \'mark_read_response\',\n                        \'notification_id\': notification_id,\n                        \'success\': success\n                    }))\n                    \n            elif action == \'mark_all_as_read\':\n                count = await self.mark_all_notifications_as_read()\n                await self.send(text_data=json.dumps({\n                    \'type\': \'mark_all_read_response\',\n                    \'count\': count\n                }))\n                \n            elif action == \'get_notifications\':\n                notifications = await self.get_recent_notifications()\n                await self.send(text_data=json.dumps({\n                    \'type\': \'notifications_list\',\n                    \'notifications\': notifications\n                }))\n                \n            else:\n                logger.warning(f"Unknown action received: {action}")\n                \n        except json.JSONDecodeError:\n            logger.error("Invalid JSON received from client")\n            await self.send(text_data=json.dumps({\n                \'type\': \'error\',\n                \'message\': \'Invalid JSON format\'\n            }))\n        except Exception as e:\n            logger.error(f"Error processing message: {str(e)}")\n            ' additional_kwargs={} response_metadata={'id': 'msg_01T5Hqzn9qnNTMDpK8pyP4ve', 'model': 'claude-sonnet-4-20250514', 'stop_reason': 'max_tokens', 'stop_sequence': None, 'usage': {'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0, 'input_tokens': 405, 'output_tokens': 1024, 'service_tier': 'standard'}} id='run--54234d37-f6b9-4dee-ba1e-e5faa1ccf527-0' usage_metadata={'input_tokens': 405, 'output_tokens': 1024, 'total_tokens': 1429, 'input_token_details': {'cache_read': 0, 'cache_creation': 0}}